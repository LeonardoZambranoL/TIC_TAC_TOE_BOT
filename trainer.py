import pickle
import itertools
from entities import *


def definitions():
    print("""
    
Definitions
------------------------------------------------------------------------------------------------------------------------
WE WILL CALL OUR PLAYERS O OR X DEPENDING ON THE SYMBOL THE PLAY WITH.
WE ASSUME THAT O OPENS THE GAME, ALSO IN ALL OF THE FOLLOWING EXAMPLES IT IS THE FIRST PLAYER´s (O´s) TURN.

WE PUT AN INDEX IN ONE OF EACH OF THE 9 SQUARES, THE INDEXES ARE AS SUCH:
     ___ ___ ___
    | 0 | 1 | 2 |
     ___ ___ ___
    | 3 | 4 | 5 |
     ___ ___ ___
    | 6 | 7 | 8 |
     ___ ___ ___
     
WE DEFINE BOARD STATE AS THE CURRENT ARRANGE OF Xs AND Os ON THE TIC TAC TOE BOARD

WE DEFINE A RESPONSE AS THE MOVEMENT A PLAYER DOES WHEN PRESENTED A CERTAIN BOARD STATE

FOR EXAMPLE WHEN PRESENTED THE BOARD STATE:
 ___ ___ ___
|   |   | x |
 ___ ___ ___
| x | o |   |
 ___ ___ ___
| o |   |   |
 ___ ___ ___
 
A RESPONSE MIGHT BE
 
 ___ ___ ___
|   |   | x |
 ___ ___ ___
| x | o |   |
 ___ ___ ___
| o |   | o |
 ___ ___ ___


A WINNING RESPONSE IS ONE THAT LEADS TO VICTORY AS SOON AS IT IS MADE

FOR EXAMPLE IF THE BOARD STATE WERE TO BE:

 ___ ___ ___
| o | x |   |
 ___ ___ ___
| x | o |   |
 ___ ___ ___
|   |   |   |
 ___ ___ ___

THEN A WINNING RESPONSE WOULD BE:
 ___ ___ ___
| o | x |   |
 ___ ___ ___
| x | o |   |
 ___ ___ ___
|   |   | o |
 ___ ___ ___

A PLAYER IS IN A WINNING POSITION IF HE CAN MAKE A WINNING RESPONSE
 


A DOUBLE-WINNING RESPONSE IS SUCH THAT THE PLAYER WHO USES THIS RESPONSE COULD (does not necessarily can as this will 
depend on the other player´s movements) WIN BY PLACING ANOTHER ONE OF HIS SYMBOLS IN ONE OF AT LEAST 2 DIFFERENT 
POSITIONS IN HIS NEXT TURN

FOR EXAMPLE IF THE BOARD STATE WERE TO BE:

 ___ ___ ___
| o |   |   |
 ___ ___ ___
|   |   |   |
 ___ ___ ___
| x | x | o |
 ___ ___ ___

THEN A DOUBLE-WINNING RESPONSE WOULD BE:
 ___ ___ ___
| o |   | 0 |
 ___ ___ ___
|   | x |   |
 ___ ___ ___
| x |   | o |
 ___ ___ ___
BECAUSE HERE, ANOTHER CIRCLE COULD BE PLACED IN ANY OF THE SQUARES WITH INDEX 1 OR 5 AND CAUSE O TO WIN.

HOWEVER WE NEED TO BE CAREFUL WITH THIS DEFINITION AS MAKING A DOUBLE-WINNING RESPONSE DOES NOT MEAN WE WILL NOT LOOSE
IT IS IMPORTANT TO NOTICE THAT THE BOARD:
 ___ ___ ___
| o |   |   |
 ___ ___ ___
| x | x |   |
 ___ ___ ___
|   |   | o |
 ___ ___ ___
HAS AS A DOUBLE-WINNING RESPONSE, WHICH IS : 
 ___ ___ ___
| o |   | o |
 ___ ___ ___
| x | x |   |
 ___ ___ ___
|   |   | o |
 ___ ___ ___
BUT OBVIOUSLY THIS DOUBLE-"WINNING" RESPONSE WILL ACTUALLY CAUSE O TO LOOSE THE GAME.
A PLAYER IS IN A DOUBLE-WINNING POSITION IF HE CAN MAKE A DOUBLE-WINNING RESPONSE.



A NOT LOOSING RESPONSE IS A SUCH THAT IT BLOCKS AT LEAST 1 OF THE ENEMY´S WINNING RESPONSES

FOR EXAMPLE IF THE BOARD STATE WERE TO BE:

 ___ ___ ___
| x | o |   |
 ___ ___ ___
| o | x |   |
 ___ ___ ___
|   |   |   |
 ___ ___ ___

THEN A NOT LOOSING RESPONSE WOULD BE:
 ___ ___ ___
| x | o |   |
 ___ ___ ___
| o | x |   |
 ___ ___ ___
|   |   | o |
 ___ ___ ___
BECAUSE IF THE CIRCLE WAS NOT PLACED IN THE SQUARE OF INDEX 8, IT WOULD LEAD X TO A BOARD STATE IN WHICH HE COULD WIN.

WE NEED TO BE CAREFUL WITH THIS DEFINITION BECAUSE MAKING A NOT-LOOSING RESPONSE DOES NOT NECESSARILY MEAN THAT 
WE WILL NOT LOOSE THE GAME.
IT IS IMPORTANT TO NOTICE THAT THE BOARD:
 ___ ___ ___
| x |   | x |
 ___ ___ ___
| o |   |   |
 ___ ___ ___
| o | o | x |
 ___ ___ ___
HAS NOT-LOOSING RESPONSES, ONE OF THEM IS:
 ___ ___ ___
| x |   | x |
 ___ ___ ___
| o |   | o |
 ___ ___ ___
| o | o | x |
 ___ ___ ___
BUT IT IS EASY TO SEE, THAT O WILL LOOSE ANYWAYS


We define a i-board-state as a bord state in which exactly i symbols have been placed (i/2 Xs and i/2 Os if
i is even and (i//2) Xs and (i//2)+1 Os if i is odd)

For example...
 ___ ___ ___     ___ ___ ___
| o | x |   |   | x |   |   |
 ___ ___ ___     ___ ___ ___
| x | o |   |   | o | x |   |
 ___ ___ ___     ___ ___ ___
|   |   |   |   | o |   |   |
 ___ ___ ___     ___ ___ ___
are both 4-board-states
         
We say that a n-board-state, is reachable if n=0 or if it can be generated by adding the corresponding symbol 
(X if (n-1) is odd and O if (n-1) is even) to a reachable (n-1)-board-state.

From the definition, it is easy to see that al 0-board-states and 1-board-states are reachable.
------------------------------------------------------------------------------------------------------------------------
""")
    print(board_gen.__doc__)
    print(search_responses.__doc__)
    print(teach.__doc__)


def check_win(board):
    """
    Determines if a player has won the game

    :param board: the board to be checked
    :return: boolean
    """
    # INDEXES OF THE VALUES THAT HAVE TO BE EQUAL TO WIN
    # 0, 1, 2
    # 3, 4, 5
    # 6, 7, 8
    # 0, 3, 6
    # 1, 4, 7
    # 2, 5, 8
    # 0, 4, 8
    # 2, 4, 6
    for line in [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]]:
        if board[line[0]] == board[line[1]] == board[line[2]] and board[line[0]] in ["X", "O"]:
            return True
    return False


def state_printer(board, f_string=""):
    """prints a board state (board) and a comment f_string next to it"""
    BOARD = """
 {} | {} | {} 
---|---|---
 {} | {} | {}     {}
---|---|---
 {} | {} | {} 
    """
    formatting_values = [a if a else " " for a in board]
    formatting_values.insert(6, f_string)
    print(BOARD.format(*formatting_values))


def board_gen():
    """
board_gen()      //      used on step 1
------------------------------------------------------------------------------------------------------------------------
THIS FUNCTION GENERATES A LIST OF ALL STILL PLAYABLE TIC TAC TOE BOARD STATES

READS: NO FILE
SAVES: A PICKLED LIST OF ALL STILL PLAYABLE BOARDS.

MORE ABOUT:

    BOARDS ARE REPRESENTED AS 9-items-long LISTS.

    THE INDEXES ARE AS SUCH:
     ___ ___ ___
    | 0 | 1 | 2 |
     ___ ___ ___
    | 3 | 4 | 5 |
     ___ ___ ___
    | 6 | 7 | 8 |
     ___ ___ ___

    SO FOR EXAMPLE THE BOARD:
     ___ ___ ___
    | o | x |   |
     ___ ___ ___
    | x | o |   |
     ___ ___ ___
    |   |   |   |
     ___ ___ ___

    IS REPRESENTED AS: ['0','x','','x','o','','','','']
------------------------------------------------------------------------------------------------------------------------
    """

    def generate_boards():
        """
        :return: "possible_boards" a list of all still-playable tic tac toe board states
        """
        possible_boards = []
        possible_values = ["X", "O"]
        # amount of squares to fill
        for amount in range(9):
            # WHICH SQUARES TO FILL
            for combination in itertools.combinations([0, 1, 2, 3, 4, 5, 6, 7, 8], amount):
                # IN WHAT ORDER TO FILL THEM
                for permutation in itertools.permutations(combination):
                    values = ["" for a in range(9)]
                    value_counter = 0
                    # FILLING SQUARES
                    for index in permutation:
                        value_counter += 1
                        value_counter %= 2
                        values[index] = possible_values[value_counter]

                    # SOMETIMES, MULTIPLE PERMUTATIONS YIELD THE SAME BOARD
                    # AVOIDING DUPLICATES

                    if values not in possible_boards:
                        if not check_win(values):
                            if print_bool:
                                state_printer(values, "NEW BOARD SAVED")
                            possible_boards.append(values)
                        else:
                            if print_bool:
                                state_printer(values, "NO LONGER PLAYABLE, DISCARDED")
        return possible_boards

    file_path = input("UNDER WHICH PATH SHALL THE OUTPUT LIST BE SAVED ? :") + ".pickle"
    print("\n")
    print_bool = input(
        "SHOULD I PRINT THE BOARD STATES AS I GO? (DUPLICATES WILL NOT BE PRINTED TWICE) \n ANSWER 'YES' OR 'NO'")
    if print_bool == "YES":
        print_bool = True
    else:
        print_bool = False
    print("GENERATING...")
    possible_boards = generate_boards()
    print(len(possible_boards), "BOARDS GENERATED")
    # SAVING PICKLE
    print(f"SAVING TO {file_path} ...")
    with open(file_path, "wb") as f:
        pickle.dump(possible_boards, f)
    print("SAVED")
    print("STEP 1 COMPLETE")


def search_responses():
    """
search_responses()      //      used on step 2
------------------------------------------------------------------------------------------------------------------------
THIS FUNCTIONS LOOKS FOR WINNING AND NOT LOOSING RESPONSES ON BOARD STATES

READS: LOADS A PICKLED LIST OF ALL BOARDS TO BE SEARCHED THROUGH
SAVES: A PICKLED DICTIONARY WITH BOARD STATES AS KEYS AND WINNING / NOT-LOOSING RESPONSES AS VALUES


SUBFUNCTION: general_searcher() - used by the following 3 subfunctions. Depending on the order given, will act
             as described in win_searcher() and not_loose_searcher().

SUBFUNCTION: win_searcher() - searches for all winning responses
             takes a list of all playable board states.
             returns a dict containing board states as keys and their respective winning response as values and a list
             of all boards without winning responses.

SUBFUNCTION: not_lose_searcher() - searches for all not loosing responses
             takes the list and dictionary resulting from win_searcher()
             returns a dict containing board states as keys and their respective winning/not-loosing response as values
             and a list of all boards without such responses.

SUBFUNCTION: double_win_searcher() - searches for all double-winning responses
             takes the list and dictionary resulting from not_loose_searcher()
             returns a dict containing board states as keys and their respective winning/not-loosing/double-win
             response as values and a list of all boards without such responses.

We run  win_searcher() first, then not_lose_searcher() and at the end double_win_searcher(), this is because
Winning responses are to be prioritized over not-loosing and double-winning responses.And not-loosing responses are to
be prioritized over double-winning responses. We do this as it does not make sense to lose the chance to win the game
directly. It also does not make sense to lose the game, because of trying to do a double-winning response instead of
blocking the enemy´s chance to beat us as there is no point on making a double-winning responses if you won´t eve make
it to your next turn before losing, A good example of that is the following board state:
 ___ ___ ___
| o |   |   |
 ___ ___ ___   Here, if we were to prioritize double-winning responses, we would place a circle in the square of index 5
| x | x |   |  and lose the game. Instead of just losing, we can prioritize the not-losing response and place the circle
 ___ ___ ___   in the square of index 5.
|   |   | o |
 ___ ___ ___

Because of how win_searcher(), not_loose_searcher() and double_win_searcher() work and because of the order in which we
call them, We can be sure that if multiple of these response types are found for some board state, only the one being
prioritized over the others will be saved as a response on the dictionary



MORE ABOUT:

    HERE THE RESPONSES ARE STORED AS AN INDEX REPRESENTING THE SQUARE IN WHICH THE MOVEMENT TAKES PLACE

    THE INDEXES ARE AS SUCH:
     ___ ___ ___
    | 0 | 1 | 2 |
     ___ ___ ___
    | 3 | 4 | 5 |
     ___ ___ ___
    | 6 | 7 | 8 |
     ___ ___ ___

    SO FOR EXAMPLE IF THE BOARD STATE WERE TO BE:

     ___ ___ ___
    | o | x |   |
     ___ ___ ___
    | x | o |   |
     ___ ___ ___
    |   |   |   |
     ___ ___ ___

    AND THE RESPONSE TO THIS STATE IS SET AS:
     ___ ___ ___
    | o | x |   |
     ___ ___ ___
    | x | o |   |
     ___ ___ ___
    |   |   | o |
     ___ ___ ___

    then the value to the key ('0','x','','x','o','','','','') is 8
------------------------------------------------------------------------------------------------------------------------
    """

    def general_searcher(win_dict, boards, print_bool, order):
        # order = 0 ---> search for wins
        # order = 1 ---> search for not loose
        class InvalidOrder(Exception):
            pass

        if order not in [0, 1]:
            raise InvalidOrder("order must be 0 or 1. 0 to search for winning responses or 1 for not-winning responses")

        remaining_boards = []
        if print_bool:
            counter_found = 0
        while boards:
            found = False
            board = boards.pop(0)
            if board.count("X") == board.count("O"):
                if order == 0:
                    # IT IS THE FIRST PLAYER´S (O´S) TURN
                    value = "O"
                elif order == 1:
                    # IT IS THE FIRST PLAYER´S (O´S) TURN, BUT WE WILL USE X TO SEE IF THE SECOND PLAYER CAN END UP IN A
                    # A WINNING POSITION DEPENDING ON O´s RESPONSE
                    # WE WILL TRY TO FIND A RESPONSE SUCH THAT THE OTHER PLAYER DOES NOT END UP IN A WINNING POSITION
                    value = "X"

            else:
                if order == 0:
                    # IT IS THE SECOND PLAYER´S (X´S) TURN
                    value = "X"
                elif order == 1:
                    # IT IS THE SECOND PLAYER´S (X´S) TURN, BUT WE WILL USE O TO SEE IF THE FIRST PLAYER CAN END UP IN A
                    # WINNING POSITION DEPENDING ON O´s RESPONSE
                    # WE WILL TRY TO FIND A RESPONSE SUCH THAT THE OTHER PLAYER DOES NOT END UP IN A WINNING POSITION
                    value = "O"

            for index, item in enumerate(board):
                if not item:
                    response_board = board[:]
                    response_board[index] = value
                    # CHECK IF THE OTHER PLAYER CAN WIN BY PLACING HIS SYMBOL IN A CERTAIN SQUARE
                    if check_win(response_board):
                        found = True
                        # IF SEARCHING TO WIN, THE INDEX IS WHERE WE SHOULD PLACE OUR SYMBOL

                        # IF SEARCHING TO NOT LOOSE, THE INDEX IS WHERE OUR OPPONENT CAN PLACE HIS SYMBOL AND WIN
                        # IF WE DO NO COVER IT FIRST SO NOW WE WILL USE OUR CURRENT TURN TO COVER THIS SQUARE BEFORE
                        # HE DOES SO IN ORDER TO AVOID LOSING IN THE NEXT TURN
                        win_dict[tuple(board)] = index
                        if print_bool:
                            counter_found += 1
                            state_printer(board, f"STATE {counter_found}")
                            if order == 0:
                                state_printer(response_board, f"WINNING RESPONSE {counter_found}")
                            elif order == 1:
                                if value == "X":
                                    value = "O"
                                elif value == "O":
                                    value = "X"
                                response_board[index] = value
                                state_printer(response_board, f"NOT LOOSING RESPONSE {counter_found}")

                            print("_" * 50)
                        # ONE RESPONSE IS ENOUGH. ONCE WE FIND IT, WE JUT BREAK AND SEARCH FOR RESPONSES ON OTHER BOARDS
                        break
            # if for no empty square a winning response is found, we append this board to the remaining_boards list
            if not found:
                remaining_boards.append(board)

        return win_dict, remaining_boards

    def win_searcher(file_name, print_bool):
        """
        search for winning movements, returns a dict with winning responses to some board states and a list of all
        board states which lack a winning response
        """
        # as for now, we do not have any responses stored in our dictionary
        responses = {}
        with open(file_name, "rb") as f:
            all_boards = pickle.load(f)
        return general_searcher(responses, all_boards, print_bool, 0)

    def not_lose_searcher(win_dict, boards, print_bool):
        """
        tries to avoid making movements that cause the other player to end up in a winning position.

        returns the given dictionary win_dict after adding items to it, the board states from boards which have a
        not loosing response are set as the new keys and the respective not-loosing responses as the values.
        It also returns the given list boards after removing from it all boards that present a not-loosing response
        """

        return general_searcher(win_dict, boards, print_bool, 1)

    def double_win_searcher(responses, boards, print_bool):
        """
        looks if it is possible to make a double-winning response

        returns the given dictionary win_dict after adding items to it, the board states from boards which have a
        double-winning response are set as the new keys and the respective double-winning responses as the values.
        It also returns the given list boards after removing from it all boards that present a double-winning response
        """
        # remaining_boards will store the boards to which no winning response is found
        remaining_boards = []
        if print_bool:
            counter_found = 0

        while boards:
            board = boards.pop(0)
            if board.count("X") == board.count("O"):
                value = "O"
                # IT IS THE FIRST PLAYER´S (O´S) TURN

            else:
                value = "X"
                # IT IS THE SECOND PLAYER´S (X´S) TURN

            found = False
            for index, item in enumerate(board):
                if found:
                    break
                if not item:
                    # WE FIRST CHECK EACH POSSIBLE MOVEMENT
                    response_board = board[:]
                    response_board[index] = value
                    # NOW, WE CHECK IF THERE IS A DOUBLE-WINNING RESPONSE
                    # BECAUSE OF HOW IT WAS DEFINED, FOR THERE TO BE A DOUBLE-WINNING RESPONSE TO item, AT LEAST 2 OF
                    # ITS EMPTY SQUARES MUST TO BE SUCH THAT WHEN PLACING AGAIN OUR SYMBOL value (without taking into
                    # account the other player´s movements) INSIDE OF THEM, THE PLAYER HAS WON IN THE RESULTING BOARD
                    win_counter = 0
                    for i, square in enumerate(response_board):
                        if not square:
                            double_response_board = response_board[:]
                            double_response_board[i] = value
                            if check_win(double_response_board):
                                win_counter += 1
                                if win_counter == 2:
                                    counter_found += 1
                                    if print_bool:
                                        state_printer(board, f"STATE {counter_found}")
                                        state_printer(response_board, f"DOUBLE-WINNING RESPONSE {counter_found}")
                                        print("_" * 50)
                                    responses[tuple(board)] = index
                                    found = True
                                    break
            # if for no empty square a winning response is found, we append this board to the remaining_boards list
            if not found:
                remaining_boards.append(board)

        return responses, remaining_boards

    # TO READ
    file_path = input("UNDER WHICH PATH WERE ALL THE BOARDS PICKLED? : ") + ".pickle"

    # TO SAVE
    dict_path = input("UNDER WHICH PATH SHALL THE OUTPUT DICTIONARY BE SAVED ? :") + ".pickle"

    # TO PRINT
    print_bool = input("SHOULD I PRINT THE BOARD STATES AND RESPONSES AS I GO? \n ANSWER 'YES' OR 'NO' : ")
    if print_bool == "YES":
        print_bool = True
    else:
        print_bool = False

    # SEARCH FOR RESPONSES
    print("SEARCHING WINNING MOVES...")
    response_dict, remaining_boards = win_searcher(file_path, print_bool)
    print("DONE.\n")

    print("SEARCHING NOT-LOOSING MOVES...")
    response_dict, remaining_boards = not_lose_searcher(response_dict, remaining_boards, print_bool)
    print("DONE.\n")
    print()
    print("SEARCHING DOUBLE-WINNING MOVES...")
    response_dict, remaining_boards = double_win_searcher(response_dict, remaining_boards, print_bool)
    print("DONE.\n")

    # SAVE FILES
    print(f"SAVING DICTIONARY TO {dict_path}...")
    with open(dict_path, "wb") as f:
        pickle.dump(response_dict, f)
    print("DICTIONARY SAVED")

    print("STEP 2 COMPLETE\n\n")


def teach():
    """
teach()     //      used in step 3
------------------------------------------------------------------------------------------------------------------------
YOU WILL TEACH THE PC HOW TO RESPOND TO CERTAIN BOARDS, THE ONES FOR WHICH NEITHER A WINNING NOR A NOT LOOSING
RESPONSE HAVE.
THE AMOUNT OF STATES TO WHICH YOU WILL HAVE TO GIVE A RESPONSE TO VARIES DEPENDING OF HOW YOU ANSWER THEM (explanation
about this below, when discussing reachable boards) BUT YOU WILL BE PRESENTED WITH ABOUT 60 STATES

READS: A PICKLED DICTIONARY WITH ALL WINNING AND NOT LOOSING RESPONSES TO THE STILL PLAYABLE BOARD STATES WITH SUCH
       RESPONSES
READS: A PICKLED LIST OF ALL STILL PLAYABLE BOARD STATES.
SAVES: A PICKLED DICTIONARY WITH BOARD STATES AS KEYS AND RESPONSES TO THESE STATES AS VALUES

SUBFUNCTION: teach_by_hand()

    teach_by_hand.__doc__ says as follows

    Here we will teach the PC how to respond to the remaining board states.
    THE PC WILL PRESENT YOU A PYGAME WINDOW WITH SOME BOARD STATE, YOU ARE EXPECTED TO CLICK THE EMPTY SQUARE IN
    WHICH THE PLAYER SHOULD DO IT´S MOVE (YOU WILL BE PLAYING AS BOTH O AND X), THIS RESPONSE WILL BE STORED IN
    A DICTIONARY AS A VALUE WHOSE KEY IS THE PRESENTED BOARD STATE.

    HERE THE RESPONSES ARE STORED AS AN INDEX REPRESENTING THE SQUARE IN WHICH THE MOVEMENT TAKES PLACE

    THE INDEXES ARE AS SUCH:
     ___ ___ ___
    | 0 | 1 | 2 |
     ___ ___ ___
    | 3 | 4 | 5 |
     ___ ___ ___
    | 6 | 7 | 8 |
     ___ ___ ___

    SO FOR EXAMPLE IF THE BOARD STATE WERE TO BE:

     ___ ___ ___
    | o | x |   |
     ___ ___ ___
    | x | o |   |
     ___ ___ ___
    |   |   |   |
     ___ ___ ___

    AND THE RESPONSE TO THIS STATE IS SET AS:
     ___ ___ ___
    | o | x |   |
     ___ ___ ___
    | x | o |   |
     ___ ___ ___
    |   |   | o |
     ___ ___ ___

    then the value to the key ('0','x','','x','o','','','','') is 8


     We can be sure that all of the states to which the PC will have to respond to are the ones which are
     reachable from the board states produced by the responses we are about to teach it.

     For example if we teach the computer to always place a circle in the center of the board on it´s first
     turn when opening a game, to always place an X in the center (if possible) on it´s first turn when being
     the second player and to place an X in the square of index 5 on it´s first turn when being
     the second if it is not possible to place it in the center, then...
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    | o |   |   |   |   | o |   |   |   |   | o |   |   |   |   |   |   |   |   |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    |   | X |   |   |   | X |   |   |   | X |   |   | o | X |   |   |   | X | o |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___

     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    |   | x |   |   |   | X |   |   |   | X |   |   |   | o | X |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    | o |   |   |   |   | o |   |   |   |   | o |   |   |   |   |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___

     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    | X |   |   |   |   | X |   |   |   |   | X |   |   |   |   |   |   |   |   |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    |   | o |   |   |   | o |   |   |   | o |   |   | X | o |   |   |   | o | X |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___

     ___ ___ ___     ___ ___ ___     ___ ___ ___
    |   |   |   |   |   |   |   |   |   |   |   |
     ___ ___ ___     ___ ___ ___     ___ ___ ___
    |   | o |   |   |   | o |   |   |   | o |   |
     ___ ___ ___     ___ ___ ___     ___ ___ ___
    | X |   |   |   |   | X |   |   |   |   | X |
     ___ ___ ___     ___ ___ ___     ___ ___ ___

    are all of the 2-board-states which can be reached after first 2 movements, from this we can conclude that
    the 3-board-state
     ___ ___ ___
    |   |   |   |
     ___ ___ ___
    |   |   |   |
     ___ ___ ___
    | o | x | o |
     ___ ___ ___

    will never occur, as it is not reachable for this example.
    we won´t bother on giving the PC a response of what to do when presented this state, as it will actually
    never be presented to it.
    From the above said, we won´t give answer to all of the board states, just to the ones which are reachable
    from the states generated by our input.

------------------------------------------------------------------------------------------------------------------------
    """

    def teach_by_hand(response_dict, boards, print_bool):
        """
         Here we will teach the PC how to respond to the remaining board states.

         THE PC WILL PRESENT YOU A PYGAME WINDOW WITH SOME BOARD STATE, YOU ARE EXPECTED TO CLICK THE EMPTY SQUARE IN
         WHICH THE PLAYER SHOULD DO IT´S MOVE (YOU WILL BE PLAYING AS BOTH O AND X), THIS RESPONSE WILL BE STORED IN
         A DICTIONARY AS A VALUE WHOSE KEY IS THE PRESENTED BOARD STATE.

         HERE THE RESPONSES ARE STORED AS AN INDEX REPRESENTING THE SQUARE IN WHICH THE MOVEMENT TAKES PLACE

         THE INDEXES ARE AS SUCH:
          ___ ___ ___
         | 0 | 1 | 2 |
          ___ ___ ___
         | 3 | 4 | 5 |
          ___ ___ ___
         | 6 | 7 | 8 |
          ___ ___ ___

         SO FOR EXAMPLE IF THE BOARD STATE WERE TO BE:

          ___ ___ ___
         | o | x |   |
          ___ ___ ___
         | x | o |   |
          ___ ___ ___
         |   |   |   |
          ___ ___ ___

         AND THE RESPONSE TO THIS STATE IS SET AS:
          ___ ___ ___
         | o | x |   |
          ___ ___ ___
         | x | o |   |
          ___ ___ ___
         |   |   | o |
          ___ ___ ___

         then the value to the key ('0','x','','x','o','','','','') is 8

         We can be sure that all of the states to which the PC will have to respond to are the ones which are reachable
         from the board states produced by the responses we are about to teach it.

         For example if we teach the computer to always place a circle in the center of the board on it´s first
         turn when opening a game, to always place an X in the center (if possible) on it´s first turn when being
         the second player and to place an X in the square of index 5 on it´s first turn when being
         the second if it is not possible to place it in the center, then...
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        | o |   |   |   |   | o |   |   |   |   | o |   |   |   |   |   |   |   |   |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        |   | X |   |   |   | X |   |   |   | X |   |   | o | X |   |   |   | X | o |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___

         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        |   | x |   |   |   | X |   |   |   | X |   |   |   | o | X |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        | o |   |   |   |   | o |   |   |   |   | o |   |   |   |   |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___

         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        | X |   |   |   |   | X |   |   |   |   | X |   |   |   |   |   |   |   |   |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        |   | o |   |   |   | o |   |   |   | o |   |   | X | o |   |   |   | o | X |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___
        |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
         ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___     ___ ___ ___

         ___ ___ ___     ___ ___ ___     ___ ___ ___
        |   |   |   |   |   |   |   |   |   |   |   |
         ___ ___ ___     ___ ___ ___     ___ ___ ___
        |   | o |   |   |   | o |   |   |   | o |   |
         ___ ___ ___     ___ ___ ___     ___ ___ ___
        | X |   |   |   |   | X |   |   |   |   | X |
         ___ ___ ___     ___ ___ ___     ___ ___ ___

        are all of the 2-board-states which can be reached after first 2 movements, from this we can conclude that
        the 3-board-state
         ___ ___ ___
        |   |   |   |
         ___ ___ ___
        |   |   |   |
         ___ ___ ___
        | o | x | o |
         ___ ___ ___

        will never occur, as it is not reachable for this example.
        we won´t bother on giving the PC a response of what to do when presented this state, as it will actually
        never be presented to it.
        """
        counter_taught = 0
        final_dict = {}
        # INITIALIZE PYGAME
        pygame.init()
        WIDTH = 653
        HEIGHT = 653
        screen = pygame.display.set_mode((WIDTH, HEIGHT))
        CLOCK = pygame.time.Clock()
        tablero = Board(screen, 0, 0, WIDTH, HEIGHT)
        pygame.display.update()
        FPS = 30

        # heads stores the board states that are generated from the responses our bot stores and the empty board
        # In other words in heads we store all the boards that the other player might have to face.
        # We do this so that we can find all of the possible boards the other player can generate after making his move
        # and find a response to those boards.
        heads = set()
        heads.add(tuple(["" for a in range(9)]))

        def get_n(board):
            """returns int"""
            # Let board be a n-board-state, we are going to find the n
            n = 0
            for item in board:
                if item:
                    n += 1
            return n

        # We only teach the PC responses to the reachable states.
        def reachable(heads, board):
            """returns bool"""
            # If for some item in heads all of its symbols are present in the same position in board, then board is
            # reachable.
            for item in heads:
                # Let us assume that board is reachable from this item, we will check that bellow
                reachable = True
                for index, symbol in enumerate(item):
                    if symbol:
                        if symbol != board[index]:
                            # if for item, one of the symbols do no coincide, then board it is not reachable
                            # from this item and reachable will be set to False.
                            reachable = False
                            break
                # if for this item, all of the symbols coincided, then reachable remained as true, thus we can
                # just return it
                if reachable:
                    return True

            # if no item in heads meets the requirements, the board is not reachable
            return False

        while boards:
            board = boards.pop(0)

            # Let board be a n-board-state, we are going to find n
            n = get_n(board)
            # we already know that this n-board-state is reachable only if it can be generated from a (n-1)-board-state
            # so for the heads parameter, we only need to send the reachable (n-1)-board-states.

            if reachable([a for a in heads if get_n(a) == (n - 1)], board) or n == 0:

                # If this board already has a set response in our previous dictionary, we keep that response
                if tuple(board) in response_dict.keys():
                    index = response_dict[tuple(board)]
                    final_dict[tuple(board)] = index

                    if board.count("X") == board.count("O"):
                        value = "O"
                        # IT IS THE FIRST PLAYER´S (O´S) TURN
                    else:
                        value = "X"
                        # IT IS THE SECOND PLAYER´S (X´S) TURN

                    response_board = board[:]
                    response_board[int(index)] = value
                    heads.add(tuple(response_board))
                # If this board does not have a set response in our previous dictionary, we give in one in by hand
                else:
                    screen.fill(BLACK)
                    tablero.draw_table()
                    tablero.values = board
                    tablero.draw_symbols()

                    if print_bool:
                        counter_taught += 1
                        state_printer(board, f"STATE {counter_taught}")
                    running = True
                    while running:
                        pygame.display.update()
                        CLOCK.tick(FPS)
                        for event in pygame.event.get():
                            if event.type == pygame.QUIT:
                                # PROGRESS WILL BE LOST
                                pygame.quit()
                                running = False

                            elif event.type == pygame.KEYDOWN:
                                if event.key == pygame.K_ESCAPE:
                                    # PROGRESS WILL BE LOST
                                    pygame.quit()
                                    running = False

                            elif event.type == pygame.MOUSEBUTTONDOWN:
                                if event.button == 1:
                                    x, y = pygame.mouse.get_pos()
                                    x = x // (WIDTH / 3)
                                    y = y // (HEIGHT / 3)
                                    index = int(x + 3 * y)
                                    final_dict[tuple(board)] = index
                                    running = False

                                    if board.count("X") == board.count("O"):
                                        value = "O"
                                        # IT IS THE FIRST PLAYER´S (O´S) TURN
                                    else:
                                        value = "X"
                                        # IT IS THE SECOND PLAYER´S (X´S) TURN

                                    response_board = board[:]
                                    response_board[int(index)] = value
                                    if print_bool:
                                        state_printer(response_board, f"RESPONSE {counter_taught}")
                                        print("_" * 50)
                                    heads.add(tuple(response_board))

            else:
                if print_bool:
                    state_printer(board, "UNREACHABLE BOARD")
                    print("_" * 50)

        return final_dict

    order = "H"  # input("ENTER 'H' TO TEACH THE COMPUTER BY HAND OR 'R' TO LET IT TEACH ITSELF RANDOMLY : ")
    list_path = input("UNDER WHICH PATH WAS THE LIST CONTAINING ALL PLAYABLE BOARDS SAVED? : ") + ".pickle"
    dict_path = input("UNDER WHICH PATH WAS THE DICTIONARY RESULTING FROM STEP 2 SAVED? : ") + ".pickle"
    file_path = input("UNDER WHICH PATH SHOULD THE RESULTING DICTIONARY BE SAVED? : ") + ".pickle"

    print_bool = input("SHOULD I PRINT THE BOARD STATES AND RESPONSES AS I GO? \n ANSWER 'YES' OR 'NO' \
    (i recommend to answer 'YES') : ")
    if print_bool == "YES":
        print_bool = True
    else:
        print_bool = False

    with open(list_path, "rb") as f:
        remaining_boards = pickle.load(f)

    with open(dict_path, "rb") as f:
        response_dict = pickle.load(f)

    if order == "H":
        result = teach_by_hand(response_dict, remaining_boards, print_bool)
        with open(file_path, "wb") as f:
            pickle.dump(result, f)
    elif order == "R":
        pass


order = input("""\
STEPS ARE TO BE FOLLOWED ACCORDING TO THE NEXT ORDER AS EACH STEP DEPENDS ON THE LAST ONE.

1) GENERATE ALL POSSIBLE BOARDS SUCH THAT THE GAME CAN STILL BE PLAYED.
2) SEARCH FOR WINNING AND NOT-LOOSING RESPONSES.
3) FOR THE REMAINING BOARDS, YOU WILL TEACH THE PC HOW TO RESPOND.

AFTER EACH STEP, SOME ELEMENT IS STORED AS A .pickle FILE.

1) A LIST OF ALL POSSIBLE BOARDS.
2) A DICTIONARY CONTAINING BOARD STATES AS KEYS AND WINNING/NOT-LOOSING RESPONSES AS VALUES AND A LIST OF ALL BOARDS 
   WHICH LACK THIS RESPONSES.
3) A DICTIONARY CONTAINING ALL (REACHABLE) BOARDS AND THE RESPECTIVE RESPONSES

THE EXTENSION .pickle WILL BE USED FOR ALL OUTPUT AND INPUT FILES

TO GET HELP ON THE DEFINITIONS, INPUT 'H'
WHICH STEP IS TO BE EXECUTED ? : """)

print(2 * "\n")

if order == "1":
    board_gen()
    order = input("WANT TO CONTINUE TO STEP 2? ANSWER 'YES' or 'NO':")
    if order == "YES":
        search_responses()
        order = input("WANT TO CONTINUE TO STEP 3? ANSWER 'YES' or 'NO':")
        if order == "YES":
            teach()

elif order == "2":
    search_responses()
    order = input("WANT TO CONTINUE TO STEP 3? ANSWER 'YES' or 'NO':")
    if order == "YES":
        teach()
elif order == "3":
    teach()
elif order == "H":
    definitions()
else:
    print("INVALID ORDER RECEIVED")
